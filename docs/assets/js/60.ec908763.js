(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{460:function(e,n,a){"use strict";a.r(n);var t=a(2),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("'「ゼロからのOS自作入門」3章 3.1〜3.3を実行します(前編)'")]),e._v(" "),a("ClientOnly",[a("CallInArticleAdsense")],1),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#ブートローダからピクセルを描く"}},[e._v("ブートローダからピクセルを描く")])]),a("li",[a("a",{attrs:{href:"#カーネルからピクセルを描く"}},[e._v("カーネルからピクセルを描く")])]),a("li",[a("a",{attrs:{href:"#エラー処理"}},[e._v("エラー処理")])]),a("li",[a("a",{attrs:{href:"#まとめ"}},[e._v("まとめ")])]),a("li",[a("a",{attrs:{href:"#参考サイト"}},[e._v("参考サイト")])])])]),a("p"),e._v(" "),a("p",[a("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[a("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/0866/000000029835.jpg",width:"728",height:"90"}})]),a("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835",width:"1",height:"1"}})]),e._v(" "),a("p",[a("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[a("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/1115/000000025847.png",width:"728",height:"90"}})]),a("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847",width:"1",height:"1"}})]),e._v(" "),a("h2",{attrs:{id:"ブートローダからピクセルを描く"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ブートローダからピクセルを描く"}},[e._v("#")]),e._v(" ブートローダからピクセルを描く")]),e._v(" "),a("p",[e._v("UEFIにあるGOP(Graphics Output Protocol)という機能によりピクセル単位で描画するのに必要な情報を得ることができます．")]),e._v(" "),a("ul",[a("li",[e._v("フレームバッファのアドレス．フレームバッファ(Frame Buffer)とはピクセルを敷き詰めたメモリ領域のことです．フレームバッファの各点に値を書き込むと，それがディスプレイのピクセルに反映される仕組みとなっています．")]),e._v(" "),a("li",[e._v("フレームバッファの表示領域の幅と高さ．解像度とも言います．")]),e._v(" "),a("li",[e._v("フレームバッファの非表示領域を含めた幅．フレームバッファには，表示領域の右側に表示されない余分な横幅が存在することがあります．")]),e._v(" "),a("li",[e._v("1ピクセルのデータ形式．フレームバッファの中で1ピクセルが何バイトで表示されているか，RGBの3色が何バイトずつどんな順番で並んでいるかという情報です．1ピクセルが8ビットであれば256(2"),a("sup",[e._v("8")]),e._v(")色，各色8ビットであれば役1677万色(2"),a("sup",[e._v("24")]),e._v(")の表示が可能です．")])]),e._v(" "),a("p",[e._v("GOPを取得して画面描画するところをMain.cに記述する．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('EFI_STATUS OpenGOP(EFI_HANDLE image_handle,\n                   EFI_GRAPHICS_OUTPUT_PROTOCOL** gop) {\n  UINTN num_gop_handles = 0;\n  EFI_HANDLE* gop_handles = NULL;\n  gBS->LocateHandleBuffer(\n      ByProtocol,\n      &gEfiGraphicsOutputProtocolGuid,\n      NULL,\n      &num_gop_handles,\n      &gop_handles);\n\n  gBS->OpenProtocol(\n      gop_handles[0],\n      &gEfiGraphicsOutputProtocolGuid,\n      (VOID**)gop,\n      image_handle,\n      NULL,\n      EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n\n  FreePool(gop_handles);\n\n  return EFI_SUCCESS;\n}\n\nconst CHAR16* GetPixelFormatUnicode(EFI_GRAPHICS_PIXEL_FORMAT fmt) {\n  switch (fmt) {\n    case PixelRedGreenBlueReserved8BitPerColor:\n      return L"PixelRedGreenBlueReserved8BitPerColor";\n    case PixelBlueGreenRedReserved8BitPerColor:\n      return L"PixelBlueGreenRedReserved8BitPerColor";\n    case PixelBitMask:\n      return L"PixelBitMask";\n    case PixelBltOnly:\n      return L"PixelBltOnly";\n    case PixelFormatMax:\n      return L"PixelFormatMax";\n    default:\n      return L"InvalidPixelFormat";\n  }\n}\n')])])]),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// UefiMain()の中に記述\n// #@@range_begin(gop)\nEFI_GRAPHICS_OUTPUT_PROTOCOL* gop;\nOpenGOP(image_handle, &gop);\nPrint(L"Resolution: %ux%u, Pixel Format: %s, %u pixels/line\\n",\n      gop->Mode->Info->HorizontalResolution,\n      gop->Mode->Info->VerticalResolution,\n      GetPixelFormatUnicode(gop->Mode->Info->PixelFormat),\n      gop->Mode->Info->PixelsPerScanLine);\nPrint(L"Frame Buffer: 0x%0lx - 0x%0lx, Size: %lu bytes\\n",\n      gop->Mode->FrameBufferBase,\n      gop->Mode->FrameBufferBase + gop->Mode->FrameBufferSize,\n      gop->Mode->FrameBufferSize);\n\nUINT8* frame_buffer = (UINT8*)gop->Mode->FrameBufferBase;\nfor (UINTN i = 0; i < gop->Mode->FrameBufferSize; ++i){\n  frame_buffer[i] = 255;\n}\n// #@@range_end(gop)\n')])])]),a("p",[e._v("Qemuを起動すると，下記のコードのようになる．")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/edk2\n\n"),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/workspaces/mikanos-devcontainer/mikanos/kernel/kernel.elf\n")])])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/image/mikanos_0304.png",loading:"lazy"}})]),e._v(" "),a("h2",{attrs:{id:"カーネルからピクセルを描く"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#カーネルからピクセルを描く"}},[e._v("#")]),e._v(" カーネルからピクセルを描く")]),e._v(" "),a("p",[e._v("カーネルからピクセルを描く際は，main.cppに下記を記述する．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include <cstdint>\n\nextern "C" void KernelMain(uint64_t frame_buffer_base,\n                           uint64_t frame_buffer_size){\n  uint8_t* frame_buffer = reinterpret_cast<uint8_t*>(frame_buffer_base);\n  for (uint64_t i = 0; i < frame_buffer_size; ++i>){\n    frame_buffer[i] = i % 256;\n  }\n  while(1) __asm__("hlt");\n}\n')])])]),a("p",[e._v("下記のコードでC++が「#include ＜cstdint＞」を使えるようにします．")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("source")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/buildenv.sh\n\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$CPPFLAGS")]),e._v("\n")])])]),a("p",[e._v("「#include ＜cstdint＞」を使えるようにしたので，clang++でコンパイルします．")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" /home/vscode/workspaces/mikanos-devcontainer/mikanos/kernel\n\nclang++ "),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$CPPFLAGS")]),e._v(" -O2 --target"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("x86_64-elf -ffreestanding -fno-exceptions -c main.cpp\n\nld.lld "),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$LDFLAGS")]),e._v(" --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o\n")])])]),a("p",[e._v("そして，Main.cに「フレームバッファの情報をカーネルに渡す」コードを記述します．")]),e._v(" "),a("p",[e._v("「entry_point」に「gop->Mode->FrameBufferBase」と「gop->Mode->FrameBufferSize」を渡して，main.cppの「KernelMain(uint64_t frame_buffer_base, uint64_t frame_buffer_size)」を実行させます．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// #@@range_begin(call_kernel)\nUINT64 entry_addr = *(UINT64*)(kernel_base_addr + 24);\n\ntypedef void EntryPointType(UINT64, UINT64);\nEntryPointType* entry_point = (EntryPointType*)entry_addr;\nentry_point(gop->Mode->FrameBufferBase, gop->Mode->FrameBufferSize);\n// #@@range_end(call_kernel)\n")])])]),a("p",[e._v("Qemuを起動すると，下記のコードのようになる．")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/edk2\n\n"),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/workspaces/mikanos-devcontainer/mikanos/kernel/kernel.elf\n")])])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/image/mikanos_0305.png",loading:"lazy"}})]),e._v(" "),a("h2",{attrs:{id:"エラー処理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#エラー処理"}},[e._v("#")]),e._v(" エラー処理")]),e._v(" "),a("p",[e._v("上記のコードでは無限ループを発生させているので，下記のコードをMain.cに追記・修正して，エラーと処理できるようにします．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// #@@range_begin(alloc_error)\nEFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000;\nstatus = gBS->AllocatePages(\n    AllocateAddress, EfiLoaderData,\n    (kernel_file_size + 0xfff) / 0x1000, &kernel_base_addr);\nif (EFI_ERROR(status)) {\n  Print(L"failed to allocate pages: %r", status);\n  Halt();\n}\n// #@@range_end(alloc_error)\n')])])]),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// #@@range_begin(halt)\nvoid Halt(void) {\n  while (1) __asm__("hlt");\n}\n// #@@range_end(halt)\n')])])]),a("p",[e._v("さらに，各工程でエラー処理をするために，「EFI_STATUS status」に各処理内容を入れて，if文でエラー処理を実行させる．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 例\nEFI_STATUS SaveMemoryMap(省略){\n  EFI_STATUS status;\n  (省略)\n  status = file->Write(file, &len, header);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n  (省略)\n}\n")])])]),a("p",[e._v("また，Main.cは下記のように記述される．")]),e._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include  <Uefi.h>\n#include  <Library/UefiLib.h>\n#include  <Library/UefiBootServicesTableLib.h>\n#include  <Library/PrintLib.h>\n#include  <Protocol/LoadedImage.h>\n#include  <Protocol/SimpleFileSystem.h>\n#include  <Protocol/DiskIo2.h>\n#include  <Protocol/BlockIo.h>\n#include  <Guid/FileInfo.h>\n\n// #@@range_begin(include)\n#include <Library/MemoryAllocationLib.h>\n// #@@range_end(include)\n\nstruct MemoryMap{\n  UINTN buffer_size;\n  VOID* buffer;\n  UINTN map_size;\n  UINTN map_key;\n  UINTN descriptor_size;\n  UINT32 descriptor_version;\n};\n\nEFI_STATUS GetMemoryMap(struct MemoryMap* map) {\n  if (map->buffer == NULL) {\n    return EFI_BUFFER_TOO_SMALL;\n  }\n\n  map->map_size = map->buffer_size;\n  return gBS->GetMemoryMap(\n      &map->map_size,\n      (EFI_MEMORY_DESCRIPTOR*)map->buffer,\n      &map->map_key,\n      &map->descriptor_size,\n      &map->descriptor_version);\n}\n\n\nconst CHAR16* GetMemoryTypeUnicode(EFI_MEMORY_TYPE type) {\n  switch (type) {\n    case EfiReservedMemoryType: return L"EfiReservedMemoryType";\n    case EfiLoaderCode: return L"EfiLoaderCode";\n    case EfiLoaderData: return L"EfiLoaderData";\n    case EfiBootServicesCode: return L"EfiBootServicesCode";\n    case EfiBootServicesData: return L"EfiBootServicesData";\n    case EfiRuntimeServicesCode: return L"EfiRuntimeServicesCode";\n    case EfiRuntimeServicesData: return L"EfiRuntimeServicesData";\n    case EfiConventionalMemory: return L"EfiConventionalMemory";\n    case EfiUnusableMemory: return L"EfiUnusableMemory";\n    case EfiACPIReclaimMemory: return L"EfiACPIReclaimMemory";\n    case EfiACPIMemoryNVS: return L"EfiACPIMemoryNVS";\n    case EfiMemoryMappedIO: return L"EfiMemoryMappedIO";\n    case EfiMemoryMappedIOPortSpace: return L"EfiMemoryMappedIOPortSpace";\n    case EfiPalCode: return L"EfiPalCode";\n    case EfiPersistentMemory: return L"EfiPersistentMemory";\n    case EfiMaxMemoryType: return L"EfiMaxMemoryType";\n    default: return L"InvalidMemoryType";\n  }\n}\n\nEFI_STATUS SaveMemoryMap(struct MemoryMap* map, EFI_FILE_PROTOCOL* file){\n  EFI_STATUS status;\n  CHAR8 buf[256];\n  UINTN len;\n  \n  CHAR8* header = "Index Type, Type(name), PhysicalStart, NumberOfPages, Attribute\\n";\n  len = AsciiStrLen(header);\n  status = file->Write(file, &len, header);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  Print(L"map->buffer = %08lx, map->map_size = %08lx\\n", \n      map->buffer, map->map_size);\n\n  EFI_PHYSICAL_ADDRESS iter;\n  int i;\n  for (iter = (EFI_PHYSICAL_ADDRESS)map->buffer, i = 0;\n  iter < (EFI_PHYSICAL_ADDRESS)map->buffer + map->map_size;\n  iter += map->descriptor_size, i++){\n    EFI_MEMORY_DESCRIPTOR* desc = (EFI_MEMORY_DESCRIPTOR*)iter;\n    len = AsciiSPrint(\n      buf, sizeof(buf),\n      "%u, %x, %-ls, %08lx, %lx, %lx\\n",\n      i, desc->Type, GetMemoryTypeUnicode(desc->Type),\n      desc->PhysicalStart, desc->NumberOfPages,\n      desc->Attribute & 0xffffflu);\n    status = file->Write(file, &len, buf);\n    if (EFI_ERROR(status)) {\n      return status;\n      }\n  }\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS OpenRootDir(EFI_HANDLE image_handle, EFI_FILE_PROTOCOL** root){\n  EFI_STATUS status;\n  EFI_LOADED_IMAGE_PROTOCOL* loaded_image;\n  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs;\n\n  status = gBS->OpenProtocol(\n    image_handle,\n    &gEfiLoadedImageProtocolGuid,\n    (VOID**)&loaded_image,\n    image_handle,\n    NULL,\n    EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  status = gBS->OpenProtocol(\n    loaded_image->DeviceHandle,\n    &gEfiSimpleFileSystemProtocolGuid,\n    (VOID**)&fs,\n    image_handle,\n    NULL,\n    EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n  return fs->OpenVolume(fs, root);\n}\n\nEFI_STATUS OpenGOP(EFI_HANDLE image_handle,\n                   EFI_GRAPHICS_OUTPUT_PROTOCOL** gop) {\n  EFI_STATUS status;\n  UINTN num_gop_handles = 0;\n  EFI_HANDLE* gop_handles = NULL;\n  status = gBS->LocateHandleBuffer(\n      ByProtocol,\n      &gEfiGraphicsOutputProtocolGuid,\n      NULL,\n      &num_gop_handles,\n      &gop_handles);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n  status = gBS->OpenProtocol(\n      gop_handles[0],\n      &gEfiGraphicsOutputProtocolGuid,\n      (VOID**)gop,\n      image_handle,\n      NULL,\n      EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  FreePool(gop_handles);\n\n  return EFI_SUCCESS;\n}\n\nconst CHAR16* GetPixelFormatUnicode(EFI_GRAPHICS_PIXEL_FORMAT fmt) {\n  switch (fmt) {\n    case PixelRedGreenBlueReserved8BitPerColor:\n      return L"PixelRedGreenBlueReserved8BitPerColor";\n    case PixelBlueGreenRedReserved8BitPerColor:\n      return L"PixelBlueGreenRedReserved8BitPerColor";\n    case PixelBitMask:\n      return L"PixelBitMask";\n    case PixelBltOnly:\n      return L"PixelBltOnly";\n    case PixelFormatMax:\n      return L"PixelFormatMax";\n    default:\n      return L"InvalidPixelFormat";\n  }\n}\n\n// #@@range_begin(halt)\nvoid Halt(void) {\n  while (1) __asm__("hlt");\n}\n// #@@range_end(halt)\n\nEFI_STATUS EFIAPI UefiMain(\n    // ウィンドウ等を操作したいときに対象を識別するために割り当てられる一意の番号\n    EFI_HANDLE image_handle,\n    // データを入れる表\n    EFI_SYSTEM_TABLE* system_table) {\n\n  EFI_STATUS status;\n\n  Print(L"Hello, Mikan World!\\n");\n\n  CHAR8 memmap_buf[4096 * 4];\n  struct MemoryMap memmap = {sizeof(memmap_buf), memmap_buf, 0, 0, 0, 0};\n  status = GetMemoryMap(&memmap);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to get memory map: %r\\n", status);\n    Halt();\n  }\n  Print(L"GetMemoryMap done\\n");\n\n  EFI_FILE_PROTOCOL* root_dir;\n  status = OpenRootDir(image_handle, &root_dir);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open root directry: %r\\n", status);\n    Halt();\n  }\n\n  Print(L"OpenRootDir done\\n");\n\n  EFI_FILE_PROTOCOL* memmap_file;\n  status = root_dir->Open(\n    root_dir, &memmap_file, L"\\\\memmap",\n    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE, 0);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open file \'\\\\memmap\': %r\\n", status);\n    Print(L"Ignored.\\n");\n  } else {\n    status = SaveMemoryMap(&memmap, memmap_file);\n    if (EFI_ERROR(status)) {\n      Print(L"failed to save memory map: %r\\n", status);\n      Halt();\n    }\n    status = memmap_file->Close(memmap_file);\n    if (EFI_ERROR(status)) {\n      Print(L"failed to close memory map: %r\\n", status);\n      Halt();\n    }\n  }\n\n  Print(L"EFI_FILE_PROTOCOL done\\n");\n\n  // #@@range_begin(gop)\n  EFI_GRAPHICS_OUTPUT_PROTOCOL* gop;\n  status = OpenGOP(image_handle, &gop);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open GOP: %r\\n", status);\n    Halt();\n  }\n  Print(L"Resolution: %ux%u, Pixel Format: %s, %u pixels/line\\n",\n        gop->Mode->Info->HorizontalResolution,\n        gop->Mode->Info->VerticalResolution,\n        GetPixelFormatUnicode(gop->Mode->Info->PixelFormat),\n        gop->Mode->Info->PixelsPerScanLine);\n  Print(L"Frame Buffer: 0x%0lx - 0x%0lx, Size: %lu bytes\\n",\n        gop->Mode->FrameBufferBase,\n        gop->Mode->FrameBufferBase + gop->Mode->FrameBufferSize,\n        gop->Mode->FrameBufferSize);\n\n  UINT8* frame_buffer = (UINT8*)gop->Mode->FrameBufferBase;\n  for (UINTN i = 0; i < gop->Mode->FrameBufferSize; ++i){\n    frame_buffer[i] = 255;\n  }\n  // #@@range_end(gop)\n\n  // #@@range_begin(read_kernel)\n  EFI_FILE_PROTOCOL* kernel_file;\n  status = root_dir->Open(\n    root_dir, &kernel_file, L"\\\\kernel.elf",\n    EFI_FILE_MODE_READ, 0);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open file \'\\\\kernel.elf\': %r\\n", status);\n    Halt();\n  }\n\n  UINTN file_info_size = sizeof(EFI_FILE_INFO) + sizeof(CHAR16) * 12;\n  UINT8 file_info_buffer[file_info_size];\n  status = kernel_file->GetInfo(\n    kernel_file, &gEfiFileInfoGuid,\n    &file_info_size, file_info_buffer);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to get file information: %r\\n", status);\n    Halt();\n  }\n\n  EFI_FILE_INFO* file_info = (EFI_FILE_INFO*)file_info_buffer;\n  UINTN kernel_file_size = file_info->FileSize;\n\n  // #@@range_begin(alloc_error)\n  EFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000;\n  status = gBS->AllocatePages(\n      AllocateAddress, EfiLoaderData,\n      (kernel_file_size + 0xfff) / 0x1000, &kernel_base_addr);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to allocate pages: %r", status);\n    Halt();\n  }\n  // #@@range_end(alloc_error)\n  // #@@range_end(read_kernel)\n\n  status = kernel_file->Read(kernel_file, &kernel_file_size, (VOID*)kernel_base_addr);\n  if (EFI_ERROR(status)) {\t\n    Print(L"error: %r", status);\t\n    Halt();\t\n  }\n  Print(L"Kernel: 0x%0lx (%lu bytes)\\n", kernel_base_addr, kernel_file_size);\n\n  // #@@range_begin(exit_bs)\n  status = gBS->ExitBootServices(image_handle, memmap.map_key);\n  if (EFI_ERROR(status)){\n    status = GetMemoryMap(&memmap);\n    if (EFI_ERROR(status)){\n      Print(L"failed to get memory map: %r\\n", status);\n      Halt();\n    }\n    status = gBS->ExitBootServices(image_handle, memmap.map_key);\n    if (EFI_ERROR(status)){\n      Print(L"Could not exit boot service: %r\\n", status);\n      Halt();\n    }\n  }\n  // #@@range_end(exit_bs)\n\n  // #@@range_begin(call_kernel)\n  UINT64 entry_addr = *(UINT64*)(kernel_base_addr + 24);\n\n  typedef void EntryPointType(UINT64, UINT64);\n  EntryPointType* entry_point = (EntryPointType*)entry_addr;\n  entry_point(gop->Mode->FrameBufferBase, gop->Mode->FrameBufferSize);\n  // #@@range_end(call_kernel)\n\n  Print(L"All done\\n");\n\n  while (1);\n  return EFI_SUCCESS;\n}\n')])])]),a("p",[e._v("Qemuを起動すると，下記のコードのようになる．")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/edk2\n\n"),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/workspaces/mikanos-devcontainer/mikanos/kernel/kernel.elf\n")])])]),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"","data-src":"/image/mikanos_0305.png",loading:"lazy"}})]),e._v(" "),a("h2",{attrs:{id:"まとめ"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#まとめ"}},[e._v("#")]),e._v(" まとめ")]),e._v(" "),a("p",[e._v("「ゼロからのOS自作入門」3章 3.1〜3.3を実行しました(前編)．")]),e._v(" "),a("h2",{attrs:{id:"参考サイト"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考サイト"}},[e._v("#")]),e._v(" 参考サイト")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://qiita.com/yoyomion/items/6e3e2648830c457ffe52",target:"_blank",rel:"noopener noreferrer"}},[e._v("clangの最適化で動作が変わった"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[a("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/0866/000000029835.jpg",width:"728",height:"90"}})]),a("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835",width:"1",height:"1"}})]),e._v(" "),a("p",[a("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[a("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/1115/000000025847.png",width:"728",height:"90"}})]),a("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847",width:"1",height:"1"}})]),e._v(" "),a("ClientOnly",[a("CallInArticleAdsense")],1)],1)}),[],!1,null,null,null);n.default=r.exports}}]);