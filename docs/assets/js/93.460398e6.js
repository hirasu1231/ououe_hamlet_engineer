(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{448:function(e,n,t){"use strict";t.r(n);var r=t(2),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("'「ゼロからのOS自作入門」4章 4.1〜4.2を実行します(前編)'")]),e._v(" "),t("ClientOnly",[t("CallInArticleAdsense")],1),e._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#makefileの作成"}},[e._v("Makefileの作成")])]),t("li",[t("a",{attrs:{href:"#ピクセルを自在に描く"}},[e._v("ピクセルを自在に描く")]),t("ul",[t("li",[t("a",{attrs:{href:"#フレームバッファの構成情報を表す構造体"}},[e._v("フレームバッファの構成情報を表す構造体")])]),t("li",[t("a",{attrs:{href:"#ブートローダがos本体に描画に必要な情報を渡す処理"}},[e._v("ブートローダがOS本体に描画に必要な情報を渡す処理")])]),t("li",[t("a",{attrs:{href:"#writepixel-を使って描画する処理"}},[e._v("WritePixel()を使って描画する処理")])]),t("li",[t("a",{attrs:{href:"#writepixel-の実装"}},[e._v("WritePixel()の実装")])]),t("li",[t("a",{attrs:{href:"#makefile"}},[e._v("MakeFile")])])])]),t("li",[t("a",{attrs:{href:"#hello-worldの実行"}},[e._v("Hello worldの実行")]),t("ul",[t("li",[t("a",{attrs:{href:"#ファイルの中身"}},[e._v("ファイルの中身")])]),t("li",[t("a",{attrs:{href:"#ビルド"}},[e._v("ビルド")])]),t("li",[t("a",{attrs:{href:"#hello-world"}},[e._v("Hello world")])])])]),t("li",[t("a",{attrs:{href:"#まとめ"}},[e._v("まとめ")])]),t("li",[t("a",{attrs:{href:"#参考サイト"}},[e._v("参考サイト")])])])]),t("p"),e._v(" "),t("p",[t("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[t("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/0866/000000029835.jpg",width:"728",height:"90"}})]),t("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835",width:"1",height:"1"}})]),e._v(" "),t("p",[t("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[t("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/1115/000000025847.png",width:"728",height:"90"}})]),t("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847",width:"1",height:"1"}})]),e._v(" "),t("h2",{attrs:{id:"makefileの作成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#makefileの作成"}},[e._v("#")]),e._v(" Makefileの作成")]),e._v(" "),t("p",[e._v("下記のコードのkernel/Makefileを作成します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("TARGET = kernel.elf\nOBJS = main.o\n\nCXXFLAGS += -O2 -Wall -g --target=x86_64-elf -ffreestanding -mno-red-zone \\\n            -fno-exceptions -fno-rtti -std=c++17\nLDFLAGS  += --entry KernelMain -z norelro --image-base 0x100000 --static\n\n.PHONY:\tall\nall: $(TARGET)\n\n.PHONY: claen\nclean: rm -rf *.o\n\nkernel.elf: $(OBJS) Makefile\n\tld.lld $(LDFLAGS) -o kernel.elf $(OBJS)\n\n%.o: %.cpp Makefile \n\tclang++ $(CPPFLAGS) $(CXXFLAGS) -c $<\n")])])]),t("p",[e._v("Makefileの変数は下記の通りです．")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("変数名")]),e._v(" "),t("th",[e._v("意味")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("TARGET")]),e._v(" "),t("td",[e._v("このMakefileで生成する最終成果物．")])]),e._v(" "),t("tr",[t("td",[e._v("OBJS")]),e._v(" "),t("td",[e._v("TARGETを作るのに必要なオブジェクトファイル群．")])]),e._v(" "),t("tr",[t("td",[e._v("CXXFLAGS")]),e._v(" "),t("td",[e._v("コンパイルオプション")])]),e._v(" "),t("tr",[t("td",[e._v("LDFLAGS")]),e._v(" "),t("td",[e._v("リンクオプション")])])])]),e._v(" "),t("p",[e._v("Makefileの書き方として，最終成果物(TARGET)を作る上での途中で生成されるファイルもターゲットと呼び扱います．")]),e._v(" "),t("p",[e._v("上記のMakefileでは，all,clean, kernel.elf, %.oの4つのターゲット(生成されるファイル等)があります．")]),e._v(" "),t("p",[e._v("Makefileでのターゲットの書き方は以下の通りです．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ターゲット: 必須項目\n  レシピ\n// %.o: %.cpp Makefile \n//         clang++ $(CPPFLAGS) $(CXXFLAGS) -c $<\n")])])]),t("p",[e._v("PHONY(偽物)宣言は偽のTARGETを作る宣言です．")]),e._v(" "),t("p",[e._v("本来TARGETはファイルでないといけませんが，PHONY(偽物)宣言では「rm -rf *.o」のようなルール(指示)を指定します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(".PHONY: 偽ターゲット\n偽ターゲット: 必須項目(or ルール)\n  レシピ\n// .PHONY: claen\n// clean: \n//         rm -rf *.o\n")])])]),t("p",[e._v("makeの実行時に自動的に定義する変数と幹の実例を下記に示す．")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("変数名")]),e._v(" "),t("th",[e._v("意味")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("$<")]),e._v(" "),t("td",[e._v("必須項目の先頭")])]),e._v(" "),t("tr",[t("td",[e._v("$^")]),e._v(" "),t("td",[e._v("必須項目全てをスペース区切りで並べたもの")])]),e._v(" "),t("tr",[t("td",[e._v("$@")]),e._v(" "),t("td",[e._v("ターゲット(拡張子含む)")])]),e._v(" "),t("tr",[t("td",[e._v("$*")]),e._v(" "),t("td",[e._v("パターンルールにおける幹(stem)")])])])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("ターゲットパターン")]),e._v(" "),t("th",[e._v("実際のターゲット")]),e._v(" "),t("th",[e._v("$*の値(幹)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("%.o")]),e._v(" "),t("td",[e._v("foo.o")]),e._v(" "),t("td",[e._v("foo")])]),e._v(" "),t("tr",[t("td",[e._v("a.%.b")]),e._v(" "),t("td",[e._v("dir/a.foo.b")]),e._v(" "),t("td",[e._v("dir/foo")])])])]),e._v(" "),t("p",[e._v("下記のコードでMakefileを実行します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("cd /home/vscode/workspaces/mikanos-devcontainer/mikanos/kernel\nmake\n// clang++     -I/home/vscode/osbook/devenv/x86_64-elf/include/c++/v1 -I/home/vscode/osbook/devenv/x86_64-elf/include -I/home/vscode/osbook/devenv/x86_64-elf/include/freetype2     -I/home/vscode/edk2/MdePkg/Include -I/home/vscode/edk2/MdePkg/Include/X64     -nostdlibinc -D__ELF__ -D_LDBL_EQ_DBL -D_GNU_SOURCE -D_POSIX_TIMERS     -DEFIAPI='__attribute__((ms_abi))' -O2 -Wall -g --target=x86_64-elf -ffreestanding -mno-red-zone -fno-exceptions -fno-rtti -std=c++17 -c main.cpp\n// ld.lld -L/home/vscode/osbook/devenv/x86_64-elf/lib --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o\n")])])]),t("p",[e._v("実行の工程は下記の通りです．")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("all: kerel.elf\n--\x3e 必須項目 (kerel.elf) のルール (kernel.elf: main.o Makefile)\n    --\x3e 必須項目 (main.o)のルール (main.o: main.cpp Makefile)\n    --\x3e 必須項目 (Makefile)のルール　(ない)\n    --\x3e レシピの実行でclang++でmain.oの生成\n--\x3e レシピなしで何も実行しない\n")])])]),t("h2",{attrs:{id:"ピクセルを自在に描く"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ピクセルを自在に描く"}},[e._v("#")]),e._v(" ピクセルを自在に描く")]),e._v(" "),t("h3",{attrs:{id:"フレームバッファの構成情報を表す構造体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#フレームバッファの構成情報を表す構造体"}},[e._v("#")]),e._v(" フレームバッファの構成情報を表す構造体")]),e._v(" "),t("p",[e._v("/mikanos/kernel/frame_buffer_config.hppを作成します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#pragma once\n\n#include <stdint.h>\n\nenum PixelFormat {\n  kPixelRGBResv8BitPerColor,\n  kPixelBGRResv8BitPerColor,\n};\n\nstruct FrameBufferConfig {\n  uint8_t* frame_buffer;\n  uint32_t pixels_per_scan_line;\n  uint32_t horizontal_resolution;\n  uint32_t vertical_resolution;\n  enum PixelFormat pixel_format;\n};\n")])])]),t("p",[e._v("作成した/mikanos/kernel/frame_buffer_config.hppは，/mikanos/MikanLoaderPkg/にシンボリックリンクさせます．")]),e._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" ~/workspaces/mikanos-devcontainer/mikanos/kernel\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("ln")]),e._v(" frame_buffer_config.hpp "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v("/MikanLoaderPkg/\n")])])]),t("h3",{attrs:{id:"ブートローダがos本体に描画に必要な情報を渡す処理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ブートローダがos本体に描画に必要な情報を渡す処理"}},[e._v("#")]),e._v(" ブートローダがOS本体に描画に必要な情報を渡す処理")]),e._v(" "),t("p",[e._v("/mikanos/MikanLoaderPkg/Main.cに追記します．")]),e._v(" "),t("p",[e._v("追記箇所はcall_kernel付近です．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('struct FrameBufferConfig config = {\n  (UINT8*)gop->Mode->FrameBufferBase,\n  gop->Mode->Info->PixelsPerScanLine,\n  gop->Mode->Info->HorizontalResolution,\n  gop->Mode->Info->VerticalResolution,\n  0\n};\nswitch (gop->Mode->Info->PixelFormat) {\n  case PixelRedGreenBlueReserved8BitPerColor:\n    config.pixel_format = kPixelRGBResv8BitPerColor;\n    break;\n  case PixelBlueGreenRedReserved8BitPerColor:\n    config.pixel_format = kPixelBGRResv8BitPerColor;\n    break;\n  default:\n    Print(L"Unimplemented pixel format: %d\\n", gop->Mode->Info->PixelFormat);\n    Halt();\n}\n\ntypedef void EntryPointType(const struct FrameBufferConfig*);\nEntryPointType* entry_point = (EntryPointType*)entry_addr;\nentry_point(&config);\n')])])]),t("h3",{attrs:{id:"writepixel-を使って描画する処理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writepixel-を使って描画する処理"}},[e._v("#")]),e._v(" WritePixel()を使って描画する処理")]),e._v(" "),t("p",[e._v("/mikanos/kernel/main.cppに追記します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// #@@range_begin(call_write_pixel)\nextern "C" void KernelMain(const FrameBufferConfig& frame_buffer_config){\n  for (int x = 0; x < frame_buffer_config.horizontal_resolution; ++x){\n    for (int y = 0; y < frame_buffer_config.vertical_resolution; ++y){\n      WritePixel(frame_buffer_config, x, y, {255, 255, 255});\n    }\n  }\n  for (int x = 0; x < 200; ++x){\n    for (int y = 0; y < 100; ++y){\n      WritePixel(frame_buffer_config, 100 + x, 100 + y, {0, 255, 0});\n    }\n  }\n  while (1) __asm__("hlt");\n}\n// #@@range_end(call_write_pixel)\n')])])]),t("h3",{attrs:{id:"writepixel-の実装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writepixel-の実装"}},[e._v("#")]),e._v(" WritePixel()の実装")]),e._v(" "),t("p",[e._v("/mikanos/kernel/main.cppに追記します．")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// #@@range_begin(write_pixel)\nstruct PixelColor{\n  uint8_t r, g, b;\n};\n\n/** WritePixelは1つの点を描画します\n* @retval 0 成功\n* @retval 非0 失敗\n*/\nint WritePixel(const FrameBufferConfig& config,\n               int x, int y, const PixelColor& c){\n  const int pixel_position = config.pixels_per_scan_line * y + x;\n  if (config.pixel_format == kPixelRGBResv8BitPerColor){\n    uint8_t* p = &config.frame_buffer[4 * pixel_position];\n    p[0] = c.r;\n    p[1] = c.g;\n    p[2] = c.b;\n  } else if (config.pixel_format == kPixelBGRResv8BitPerColor){\n    uint8_t* p = &config.frame_buffer[4 * pixel_position];\n    p[0] = c.b;\n    p[1] = c.g;\n    p[2] = c.r;\n  } else {\n    return -1;\n  }\n  return 0;\n}\n// #@@range_end(write_pixel)\n")])])]),t("h3",{attrs:{id:"makefile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#makefile"}},[e._v("#")]),e._v(" MakeFile")]),e._v(" "),t("p",[e._v("/mikanos/kernel/Makefileを修正します．")]),e._v(" "),t("p",[e._v("LDFLAGS に -z separate-code に追加します。")]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n")])])]),t("h2",{attrs:{id:"hello-worldの実行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hello-worldの実行"}},[e._v("#")]),e._v(" Hello worldの実行")]),e._v(" "),t("h3",{attrs:{id:"ファイルの中身"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ファイルの中身"}},[e._v("#")]),e._v(" ファイルの中身")]),e._v(" "),t("p",[t("strong",[e._v("/mikanos/kernel/frame_buffer_config.hpp")])]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#pragma once\n\n#include <stdint.h>\n\nenum PixelFormat {\n  kPixelRGBResv8BitPerColor,\n  kPixelBGRResv8BitPerColor,\n};\n\nstruct FrameBufferConfig {\n  uint8_t* frame_buffer;\n  uint32_t pixels_per_scan_line;\n  uint32_t horizontal_resolution;\n  uint32_t vertical_resolution;\n  enum PixelFormat pixel_format;\n};\n\n")])])]),t("p",[t("strong",[e._v("/mikanos/MikanLoaderPkg/Main.c")])]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('#include  <Uefi.h>\n#include  <Library/UefiLib.h>\n#include  <Library/UefiBootServicesTableLib.h>\n#include  <Library/PrintLib.h>\n#include  <Library/MemoryAllocationLib.h>\n#include  <Protocol/LoadedImage.h>\n#include  <Protocol/SimpleFileSystem.h>\n#include  <Protocol/DiskIo2.h>\n#include  <Protocol/BlockIo.h>\n#include  <Guid/FileInfo.h>\n#include  "frame_buffer_config.hpp"\n\nstruct MemoryMap {\n  UINTN buffer_size;\n  VOID* buffer;\n  UINTN map_size;\n  UINTN map_key;\n  UINTN descriptor_size;\n  UINT32 descriptor_version;\n};\n\nEFI_STATUS GetMemoryMap(struct MemoryMap* map) {\n  if (map->buffer == NULL) {\n    return EFI_BUFFER_TOO_SMALL;\n  }\n\n  map->map_size = map->buffer_size;\n  return gBS->GetMemoryMap(\n      &map->map_size,\n      (EFI_MEMORY_DESCRIPTOR*)map->buffer,\n      &map->map_key,\n      &map->descriptor_size,\n      &map->descriptor_version);\n}\n\nconst CHAR16* GetMemoryTypeUnicode(EFI_MEMORY_TYPE type) {\n  switch (type) {\n    case EfiReservedMemoryType: return L"EfiReservedMemoryType";\n    case EfiLoaderCode: return L"EfiLoaderCode";\n    case EfiLoaderData: return L"EfiLoaderData";\n    case EfiBootServicesCode: return L"EfiBootServicesCode";\n    case EfiBootServicesData: return L"EfiBootServicesData";\n    case EfiRuntimeServicesCode: return L"EfiRuntimeServicesCode";\n    case EfiRuntimeServicesData: return L"EfiRuntimeServicesData";\n    case EfiConventionalMemory: return L"EfiConventionalMemory";\n    case EfiUnusableMemory: return L"EfiUnusableMemory";\n    case EfiACPIReclaimMemory: return L"EfiACPIReclaimMemory";\n    case EfiACPIMemoryNVS: return L"EfiACPIMemoryNVS";\n    case EfiMemoryMappedIO: return L"EfiMemoryMappedIO";\n    case EfiMemoryMappedIOPortSpace: return L"EfiMemoryMappedIOPortSpace";\n    case EfiPalCode: return L"EfiPalCode";\n    case EfiPersistentMemory: return L"EfiPersistentMemory";\n    case EfiMaxMemoryType: return L"EfiMaxMemoryType";\n    default: return L"InvalidMemoryType";\n  }\n}\n\nEFI_STATUS SaveMemoryMap(struct MemoryMap* map, EFI_FILE_PROTOCOL* file) {\n  EFI_STATUS status;\n  CHAR8 buf[256];\n  UINTN len;\n\n  CHAR8* header =\n    "Index, Type, Type(name), PhysicalStart, NumberOfPages, Attribute\\n";\n  len = AsciiStrLen(header);\n  status = file->Write(file, &len, header);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  Print(L"map->buffer = %08lx, map->map_size = %08lx\\n",\n      map->buffer, map->map_size);\n\n  EFI_PHYSICAL_ADDRESS iter;\n  int i;\n  for (iter = (EFI_PHYSICAL_ADDRESS)map->buffer, i = 0;\n       iter < (EFI_PHYSICAL_ADDRESS)map->buffer + map->map_size;\n       iter += map->descriptor_size, i++) {\n    EFI_MEMORY_DESCRIPTOR* desc = (EFI_MEMORY_DESCRIPTOR*)iter;\n    len = AsciiSPrint(\n        buf, sizeof(buf),\n        "%u, %x, %-ls, %08lx, %lx, %lx\\n",\n        i, desc->Type, GetMemoryTypeUnicode(desc->Type),\n        desc->PhysicalStart, desc->NumberOfPages,\n        desc->Attribute & 0xffffflu);\n    status = file->Write(file, &len, buf);\n    if (EFI_ERROR(status)) {\n      return status;\n    }\n  }\n\n  return EFI_SUCCESS;\n}\n\nEFI_STATUS OpenRootDir(EFI_HANDLE image_handle, EFI_FILE_PROTOCOL** root) {\n  EFI_STATUS status;\n  EFI_LOADED_IMAGE_PROTOCOL* loaded_image;\n  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs;\n\n  status = gBS->OpenProtocol(\n      image_handle,\n      &gEfiLoadedImageProtocolGuid,\n      (VOID**)&loaded_image,\n      image_handle,\n      NULL,\n      EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  status = gBS->OpenProtocol(\n      loaded_image->DeviceHandle,\n      &gEfiSimpleFileSystemProtocolGuid,\n      (VOID**)&fs,\n      image_handle,\n      NULL,\n      EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  return fs->OpenVolume(fs, root);\n}\n\nEFI_STATUS OpenGOP(EFI_HANDLE image_handle,\n                   EFI_GRAPHICS_OUTPUT_PROTOCOL** gop) {\n  EFI_STATUS status;\n  UINTN num_gop_handles = 0;\n  EFI_HANDLE* gop_handles = NULL;\n\n  status = gBS->LocateHandleBuffer(\n      ByProtocol,\n      &gEfiGraphicsOutputProtocolGuid,\n      NULL,\n      &num_gop_handles,\n      &gop_handles);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  status = gBS->OpenProtocol(\n      gop_handles[0],\n      &gEfiGraphicsOutputProtocolGuid,\n      (VOID**)gop,\n      image_handle,\n      NULL,\n      EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);\n  if (EFI_ERROR(status)) {\n    return status;\n  }\n\n  FreePool(gop_handles);\n\n  return EFI_SUCCESS;\n}\n\nconst CHAR16* GetPixelFormatUnicode(EFI_GRAPHICS_PIXEL_FORMAT fmt) {\n  switch (fmt) {\n    case PixelRedGreenBlueReserved8BitPerColor:\n      return L"PixelRedGreenBlueReserved8BitPerColor";\n    case PixelBlueGreenRedReserved8BitPerColor:\n      return L"PixelBlueGreenRedReserved8BitPerColor";\n    case PixelBitMask:\n      return L"PixelBitMask";\n    case PixelBltOnly:\n      return L"PixelBltOnly";\n    case PixelFormatMax:\n      return L"PixelFormatMax";\n    default:\n      return L"InvalidPixelFormat";\n  }\n}\n\nvoid Halt(void) {\n  while (1) __asm__("hlt");\n}\n\nEFI_STATUS EFIAPI UefiMain(\n    EFI_HANDLE image_handle,\n    EFI_SYSTEM_TABLE* system_table) {\n  EFI_STATUS status;\n\n  Print(L"Hello, Mikan World!\\n");\n\n  CHAR8 memmap_buf[4096 * 4];\n  struct MemoryMap memmap = {sizeof(memmap_buf), memmap_buf, 0, 0, 0, 0};\n  status = GetMemoryMap(&memmap);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to get memory map: %r\\n", status);\n    Halt();\n  }\n\n  EFI_FILE_PROTOCOL* root_dir;\n  status = OpenRootDir(image_handle, &root_dir);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open root directory: %r\\n", status);\n    Halt();\n  }\n\n  EFI_FILE_PROTOCOL* memmap_file;\n  status = root_dir->Open(\n      root_dir, &memmap_file, L"\\\\memmap",\n      EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE, 0);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open file \'\\\\memmap\': %r\\n", status);\n    Print(L"Ignored.\\n");\n  } else {\n    status = SaveMemoryMap(&memmap, memmap_file);\n    if (EFI_ERROR(status)) {\n      Print(L"failed to save memory map: %r\\n", status);\n      Halt();\n    }\n    status = memmap_file->Close(memmap_file);\n    if (EFI_ERROR(status)) {\n      Print(L"failed to close memory map: %r\\n", status);\n      Halt();\n    }\n  }\n\n  EFI_GRAPHICS_OUTPUT_PROTOCOL* gop;\n  status = OpenGOP(image_handle, &gop);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open GOP: %r\\n", status);\n    Halt();\n  }\n\n  Print(L"Resolution: %ux%u, Pixel Format: %s, %u pixels/line\\n",\n      gop->Mode->Info->HorizontalResolution,\n      gop->Mode->Info->VerticalResolution,\n      GetPixelFormatUnicode(gop->Mode->Info->PixelFormat),\n      gop->Mode->Info->PixelsPerScanLine);\n  Print(L"Frame Buffer: 0x%0lx - 0x%0lx, Size: %lu bytes\\n",\n      gop->Mode->FrameBufferBase,\n      gop->Mode->FrameBufferBase + gop->Mode->FrameBufferSize,\n      gop->Mode->FrameBufferSize);\n\n  UINT8* frame_buffer = (UINT8*)gop->Mode->FrameBufferBase;\n  for (UINTN i = 0; i < gop->Mode->FrameBufferSize; ++i) {\n    frame_buffer[i] = 255;\n  }\n\n  EFI_FILE_PROTOCOL* kernel_file;\n  status = root_dir->Open(\n      root_dir, &kernel_file, L"\\\\kernel.elf",\n      EFI_FILE_MODE_READ, 0);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to open file \'\\\\kernel.elf\': %r\\n", status);\n    Halt();\n  }\n\n  UINTN file_info_size = sizeof(EFI_FILE_INFO) + sizeof(CHAR16) * 12;\n  UINT8 file_info_buffer[file_info_size];\n  status = kernel_file->GetInfo(\n      kernel_file, &gEfiFileInfoGuid,\n      &file_info_size, file_info_buffer);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to get file information: %r\\n", status);\n    Halt();\n  }\n\n  EFI_FILE_INFO* file_info = (EFI_FILE_INFO*)file_info_buffer;\n  UINTN kernel_file_size = file_info->FileSize;\n\n  // #@@range_begin(alloc_error)\n  EFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000;\n  status = gBS->AllocatePages(\n      AllocateAddress, EfiLoaderData,\n      (kernel_file_size + 0xfff) / 0x1000, &kernel_base_addr);\n  if (EFI_ERROR(status)) {\n    Print(L"failed to allocate pages: %r", status);\n    Halt();\n  }\n  // #@@range_end(alloc_error)\n  status = kernel_file->Read(kernel_file, &kernel_file_size, (VOID*)kernel_base_addr);\n  if (EFI_ERROR(status)) {\n    Print(L"error: %r", status);\n    Halt();\n  }\n  Print(L"call_kernel\\n");\n  Print(L"Kernel: 0x%0lx (%lu bytes)\\n", kernel_base_addr, kernel_file_size);\n\n  // #@@range_begin(exit_bs)\n  status = gBS->ExitBootServices(image_handle, memmap.map_key);\n  if (EFI_ERROR(status)) {\n    status = GetMemoryMap(&memmap);\n    if (EFI_ERROR(status)) {\n      Print(L"failed to get memory map: %r\\n", status);\n      Halt();\n    }\n    status = gBS->ExitBootServices(image_handle, memmap.map_key);\n    if (EFI_ERROR(status)) {\n      Print(L"Could not exit boot service: %r\\n", status);\n      Halt();\n    }\n  }\n  // #@@range_end(exit_bs)\n  \n  // ここの周囲にPrintを記載しない\n  UINT64 entry_addr = *(UINT64*)(kernel_base_addr + 24);\n  \n  // #@@range_begin(pass_frame_buffer_config)\n  struct FrameBufferConfig config = {\n    (UINT8*)gop->Mode->FrameBufferBase,\n    gop->Mode->Info->PixelsPerScanLine,\n    gop->Mode->Info->HorizontalResolution,\n    gop->Mode->Info->VerticalResolution,\n    0\n  };\n  switch (gop->Mode->Info->PixelFormat) {\n    case PixelRedGreenBlueReserved8BitPerColor:\n      config.pixel_format = kPixelRGBResv8BitPerColor;\n      break;\n    case PixelBlueGreenRedReserved8BitPerColor:\n      config.pixel_format = kPixelBGRResv8BitPerColor;\n      break;\n    default:\n      Print(L"Unimplemented pixel format: %d\\n", gop->Mode->Info->PixelFormat);\n      Halt();\n  }\n\n  typedef void EntryPointType(const struct FrameBufferConfig*);\n  EntryPointType* entry_point = (EntryPointType*)entry_addr;\n  entry_point(&config);\n  // #@@range_end(pass_frame_buffer_config)\n  Print(L"All done\\n");\n\n  while (1);\n  return EFI_SUCCESS;\n}\n\n')])])]),t("p",[t("strong",[e._v("/mikanos/kernel/main.cpp")])]),e._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('#include <cstdint>\n#include <cstddef>\n\n#include "frame_buffer_config.hpp"\n\n// #@@range_begin(write_pixel)\nstruct PixelColor{\n  uint8_t r, g, b;\n};\n\n/** WritePixelは1つの点を描画します\n* @retval 0 成功\n* @retval 非0 失敗\n*/\nint WritePixel(const FrameBufferConfig& config,\n               int x, int y, const PixelColor& c){\n  const int pixel_position = config.pixels_per_scan_line * y + x;\n  if (config.pixel_format == kPixelRGBResv8BitPerColor){\n    uint8_t* p = &config.frame_buffer[4 * pixel_position];\n    p[0] = c.r;\n    p[1] = c.g;\n    p[2] = c.b;\n  } else if (config.pixel_format == kPixelBGRResv8BitPerColor){\n    uint8_t* p = &config.frame_buffer[4 * pixel_position];\n    p[0] = c.b;\n    p[1] = c.g;\n    p[2] = c.r;\n  } else {\n    return -1;\n  }\n  return 0;\n}\n// #@@range_end(write_pixel)\n\n// #@@range_begin(call_write_pixel)\nextern "C" void KernelMain(const FrameBufferConfig& frame_buffer_config){\n  for (int x = 0; x < frame_buffer_config.horizontal_resolution; ++x){\n    for (int y = 0; y < frame_buffer_config.vertical_resolution; ++y){\n      WritePixel(frame_buffer_config, x, y, {255, 255, 255});\n    }\n  }\n  for (int x = 0; x < 200; ++x){\n    for (int y = 0; y < 100; ++y){\n      WritePixel(frame_buffer_config, 100 + x, 100 + y, {0, 255, 0});\n    }\n  }\n  while (1) __asm__("hlt");\n}\n// #@@range_end(call_write_pixel)\n\n')])])]),t("h3",{attrs:{id:"ビルド"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ビルド"}},[e._v("#")]),e._v(" ビルド")]),e._v(" "),t("p",[e._v("下記のコードで変更したMain.c等を反映します．")]),e._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("source")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/buildenv.sh\n\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" ~/workspaces/mikanos-devcontainer/mikanos/kernel\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("make")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/edk2/\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("source")]),e._v(" edksetup.sh\nbuild\n")])])]),t("h3",{attrs:{id:"hello-world"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hello-world"}},[e._v("#")]),e._v(" Hello world")]),e._v(" "),t("p",[e._v("下記のコードでイメージファイルを上書きし，Hello Worldを実行します．")]),e._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/edk2\n\n"),t("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi "),t("span",{pre:!0,attrs:{class:"token environment constant"}},[e._v("$HOME")]),e._v("/workspaces/mikanos-devcontainer/mikanos/kernel/kernel.elf\n")])])]),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"image/WritePixel_4_2.png",loading:"lazy"}})]),e._v(" "),t("h2",{attrs:{id:"まとめ"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#まとめ"}},[e._v("#")]),e._v(" まとめ")]),e._v(" "),t("p",[e._v("「ゼロからのOS自作入門」4章 4.1〜4.2を実行しました(前編)．")]),e._v(" "),t("h2",{attrs:{id:"参考サイト"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考サイト"}},[e._v("#")]),e._v(" 参考サイト")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://noanoa07.livedoor.blog/archives/2342461.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("『ゼロからのOS自作入門』をMacで動かしてみた記録（第4章 4.2 osbook_day04b）"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[t("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/0866/000000029835.jpg",width:"728",height:"90"}})]),t("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2604050&p_id=1555&pc_id=2816&pl_id=29835",width:"1",height:"1"}})]),e._v(" "),t("p",[t("a",{attrs:{href:"//af.moshimo.com/af/c/click?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847&guid=ON",rel:"nofollow",referrerpolicy:"no-referrer-when-downgrade"}},[t("img",{staticStyle:{border:"none"},attrs:{src:"//image.moshimo.com/af-img/1115/000000025847.png",width:"728",height:"90"}})]),t("img",{staticStyle:{border:"none"},attrs:{src:"//i.moshimo.com/af/i/impression?a_id=2641145&p_id=1770&pc_id=3386&pl_id=25847",width:"1",height:"1"}})]),e._v(" "),t("ClientOnly",[t("CallInArticleAdsense")],1)],1)}),[],!1,null,null,null);n.default=a.exports}}]);